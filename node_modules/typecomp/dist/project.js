"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const TS = require("typescript");
const tsconfig = require("tsconfig");
const { assign } = Object;
class Project {
    constructor(root, registry) {
        this.host = new InMemoryLanguageServiceHost(root);
        this.service = TS.createLanguageService(this.host, registry);
    }
    resolve(filename) {
        return path.resolve(process.cwd(), filename);
    }
    index(filename) {
        this.host.addFile(filename);
    }
    diagnose(filename) {
        filename = this.resolve(filename);
        const { service } = this;
        this.index(filename);
        const syntactic = service.getSyntacticDiagnostics(filename);
        const semantic = service.getSemanticDiagnostics(filename);
        return [...syntactic, ...semantic];
    }
    compile(filename) {
        filename = this.resolve(filename);
        const { service } = this;
        this.index(filename);
        const { outputFiles } = service.getEmitOutput(filename);
        return outputFiles;
    }
}
exports.Project = Project;
function md5(input) {
    return crypto
        .createHash("md5")
        .update(input)
        .digest("hex");
}
class InMemoryLanguageServiceHost {
    constructor(root) {
        this.files = new Map();
        this.version = "";
        this.options = this.getOptions(root);
    }
    getOptions(root) {
        const configPath = tsconfig.findSync(root);
        if (typeof configPath !== "string") {
            return {};
        }
        const { config } = TS.parseConfigFileTextToJson(configPath, fs.readFileSync(configPath, "utf8"));
        const { options } = TS.parseJsonConfigFileContent(config, TS.sys, path.dirname(configPath));
        return options;
    }
    getCompilationSettings() {
        return this.options;
    }
    getNewLine() {
        return "\n";
    }
    getProjectVersion() {
        return this.version;
    }
    getScriptFileNames() {
        return [...this.files.keys()];
    }
    getScriptKind(fileName) {
        const { kind } = this.files.get(fileName) || this.addFile(fileName);
        return kind;
    }
    getScriptVersion(fileName) {
        const { version } = this.files.get(fileName) || this.addFile(fileName);
        return version;
    }
    getScriptSnapshot(fileName) {
        const { snapshot } = this.files.get(fileName) || this.addFile(fileName);
        return snapshot;
    }
    getCurrentDirectory() {
        return process.cwd();
    }
    getDefaultLibFileName(options) {
        return TS.getDefaultLibFilePath(options);
    }
    useCaseSensitiveFileNames() {
        return false;
    }
    readFile(fileName, encoding = "utf8") {
        return fs.readFileSync(fileName, encoding);
    }
    realpath(fileName) {
        return fs.realpathSync(fileName);
    }
    fileExists(fileName) {
        return fs.existsSync(fileName);
    }
    getDirectories(directoryName) {
        if (!fs.existsSync(directoryName)) {
            return [];
        }
        return fs
            .readdirSync(directoryName)
            .filter(entry => fs.statSync(path.join(directoryName, entry)).isDirectory());
    }
    addFile(fileName) {
        const text = fs.readFileSync(fileName, "utf8");
        const version = md5(text);
        const current = this.files.get(fileName);
        if (current !== undefined && current.version === version) {
            return current;
        }
        const snapshot = TS.ScriptSnapshot.fromString(text);
        this.version = md5(this.version + version);
        let kind = TS.ScriptKind.Unknown;
        switch (path.extname(fileName)) {
            case ".js":
                kind = TS.ScriptKind.JS;
                break;
            case ".jsx":
                kind = TS.ScriptKind.JSX;
                break;
            case ".ts":
                kind = TS.ScriptKind.TS;
                break;
            case ".tsx":
                kind = TS.ScriptKind.TSX;
        }
        const file = { snapshot, version, kind };
        this.files.set(fileName, file);
        return file;
    }
    removeFile(fileName) {
        this.files.delete(fileName);
    }
}
